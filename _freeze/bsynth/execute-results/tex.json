{
  "hash": "5ff50c78736bbe4cba423e83979d89ee",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bayesian Synthetic Control\"\n---\n\n\n\nSynthetic control methods have become a widely applied tool for empirical\nresearchers to estimate the effect of interventions or treatments, especially\nwhen traditional randomized controlled trials aren't feasible. In a recent\nJournal of Economic Perspectives survey on the econometrics of policy\nevaluation, Susan Athey and Guido Imbens describe synthetic controls as\n\"arguably the most important innovation in the policy evaluation literature in\nthe last 15 years\" [@athey2017state]. The technique involves creating a\n\"synthetic\" version of the treated unit by weighting untreated units from a\ndonor pool. This essentially allows us to estimate what would have happened if\nthe treatment had never occurred.\n\n## Key Concepts and Principles\n\n\nBefore we dive into the Bayesian approach, let's review some fundamental\nconcepts:\n\n**Pre-treatment Fit:** The credibility of a synthetic control estimator hinges\non how well it can track the trajectory of the outcome variable for the treated\nunit before the intervention. A close pre-treatment fit makes for more reliable\npost-treatment estimates.\n\n**Convex Hull Condition:** The synthetic control method works best when the\ncharacteristics of the treated unit fall within the convex hull of the donor\npool units' characteristics. This ensures that the treated unit can be\napproximated by a weighted average of donor units.\n\n**Sparse Solutions:** Synthetic control estimates typically involve only a few\ndonor pool units with non-zero weights. This sparsity aids in interpretability\nand helps reduce overfitting.\n\n**No Anticipation:** The method assumes that there are no anticipation effects\nbefore the intervention. If such effects exist, it's advisable to backdate the\nintervention in the dataset.\n\n**Sufficient Pre- and Post-intervention Information:** The credibility of the\nestimates depends on having enough pre-intervention periods to establish a good\nfit and enough post-intervention periods to observe the full effect of the\nintervention.\n\n**No Interference:** The method assumes that the intervention does not affect\nthe outcomes of the untreated units. This assumption should be carefully\nconsidered in the study design.\n\n## The Bayesian Advantage\n\n**Prior Information:** Bayesian methods allow us to incorporate prior knowledge\nor beliefs about the data. This can be particularly useful when we have relevant\ninformation from past studies or expert opinions.\n\n**Posterior Distribution:** By combining the prior distribution with the\nlikelihood of the observed data, we get a posterior distribution. This\ndistribution represents our updated beliefs about the parameters after taking\ninto account the new data.\n\n**Uncertainty Quantification:** One of the key strengths of Bayesian methods is\ntheir ability to quantify uncertainty. The posterior distribution gives us a\nrange of plausible values for the treatment effects, along with associated\nprobabilities.\n\n**Hierarchical Models:** Bayesian synthetic control models can be built with\nhierarchical structures. This allows for more complex relationships and\ndependencies within the data.\n\n### Mathematical Formulation\n\nIn the Bayesian approach, we typically use a Dirichlet distribution as the prior\nfor the weights, ensuring they are positive and sum to 1. We can also introduce\na scaling matrix, often denoted as Î“, to control the importance of different\npredictors.\n\nLet's formalize this with some notation:\n\n- $X_1$: A $k \\times 1$ matrix of predictors for the treated unit.\n- $X_0$: A $k \\times J$ matrix of predictors for the donor units.\n- $w$: A $J\\times 1$ vector of weights for the synthetic control.\n- $\\sigma$: A scaling parameter.\n- $\\Gamma$ A $k \\times k$ scaling matrix.\n\nA simple Bayesian synthetic control model can be formulated as:\n\n\n$$ \n\\begin{aligned}\nX_1 | w, \\sigma &\\sim N(X_0w , \\text{diag}(\\Gamma)^{-2}\\sigma^2) \\\\\nw &\\sim \\text{Dir}(1)\\\\\n\\sigma &\\sim N^+(0,1)\\\\\n\\Gamma &\\sim Dir((v_1, \\dots, v_k)') \\quad \\text{s.t. } 1'v = 1 \\\\\n\\end{aligned}\n$$\n\n\n### Practical Implementation: The German Re-unification Example\n\nIn 1989, a monumental event occurred: the reunification of East and West\nGermany. A natural question for policymakers was: \"What impact did reunification\nhave on West Germany's GDP?\"\n\nThis very question was addressed in one of the seminal papers on synthetic\ncontrol [see @abadie2015comparative]. Using a Bayesian approach, we can not only\nestimate the effect of reunification but also quantify the uncertainty around\nthat estimate.\n\nThe {bsynth} package in R provides a convenient way to apply Bayesian synthetic\ncontrol methods. Let's see how we can analyze the German reunification data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"bsynth\")\nload(\"germany.rda\")\ngermany_synth <- bayesianSynth$new(data = germany,\n                                   time = year,\n                                   id = country,\n                                   treated = D,\n                                   outcome = gdp,\n                                   ci_width = 0.95,\n                                   predictor_match = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTransforming data\n```\n\n\n:::\n\n```{.r .cell-code}\ngermany_synth$timeTiles + ggplot2::xlab(\"Year\") + ggplot2::ylab(\"Country\")\n```\n\n::: {.cell-output-display}\n![](bsynth_files/figure-pdf/germany-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nIn this example, we're starting with a simple model that doesn't include predictor matching. We'll fit the model and visualize the results:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngermany_synth$fit(cores = 4)\n\n# Vizualize the Bayesian Synthetic Control\ngermany_synth$synthetic + \n  ggplot2::xlab(\"Year\") +\n  ggplot2::ylab(\"Per Capita GDP (PPP, 2002 USD)\") +\n  ggplot2::scale_y_continuous(labels=scales::dollar_format())\n```\n\n::: {.cell-output-display}\n![](bsynth_files/figure-pdf/fit-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.content-visible when-format=\"html\"}\nWe can also examine the estimated lift (the cumulative effect of the treatment) over a specific time period:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngermany_synth$liftDraws(from = lubridate::as_date(\"1990-01-01\"), \n                        to = lubridate::as_date(\"2002-01-01\"))\n```\n:::\n\n\n:::\n\n### When Things Go Wrong: The Pitfalls of Synthetic Controls\n\nIt's crucial to remember that synthetic control isn't a magic bullet. Things can\ngo awry, and you could end up with estimates that are entirely off the mark.\nHere are some common pitfalls to watch out for:\n\n  - **Poor Pre-treatment Fit:** If your synthetic control doesn't accurately\n    replicate the treated unit's pre-treatment behavior, don't use it. It's as\n    simple as that.\n\n  - **Overfitting:** Even with a perfect pre-treatment fit, there's the danger\n    of overfitting. This is more likely to happen if you have a short\n    pre-treatment period, a large donor pool, noisy data, or if you relax the\n    weight constraints and allow for extrapolation.\n\n\n**Be careful** when using synthetic controls, things co go bad and you could end\nup with an estimate that is the wrong sign!! The weight restriction allows us\nto cleanly characterize an upper bound for the bias:\n\n\n\\begin{align*}\nE[|\\hat{\\tau}_{1t} - \\tau_{1t}|] \\lesssim \\underbrace{C_1\\mathbb{E}\\text{MAD}\\left(Y_1^P, \\hat{Y}_j^P\\right) + k C_2 \\mathbb{E}\\text{MAD}\\left(Z_1^1,\\hat{Z}_j^1\\right)}_{\\text{First Order}} + \\underbrace{C_3 J^{1/3} \\frac{\\bar{\\sigma}}{T_0^{1/2}}}_{\\text{Second Order}}\n\\end{align*}\n\n1.  **Fit matters most**: If the synthetic control can not replicate the treated\n    unit over time, you should **not** use it.\n\n2.  **Don't chase noise**: Even with perfect pre-treatment fit there is the\n    danger that you are **over-fitting** to the pre-treatment period.\n\nOver-fitting is more likely in the following situations:\n\n  - You have a short pre-treatment period (small $T_0$).\n  - You have a large donor pool (large $J$) or the units are not similar to your\n    treated unit.\n  - You have very noisy data.\n  - You allow for extrapolation by relaxing the weight constraints. In this\n    case, you might have perfect pre-treatment fit but you will likely have\n    significant bias from over-fitting.\n\n### Check the Bias of your Bayesian Synthetic Controls\n\nThe 'bsynth' package offers you a nice and easy way to check how likely it is\nthat your estimate is badly biased! By computing an upper bound on the relative\nbias we get an estimate of the probability that your effect could change signs\nbecause of the bias.\n\n\nIn the case of the German re-unification this is unlikely when we consider the\nfull post-treatment period of 12 years.\n\n::: {.content-visible when-format=\"html\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngermany_synth$biasDraws(small_bias = 0.2, \n                        firstT = lubridate::as_date(\"1990-01-01\"), \n                        lastT = lubridate::as_date(\"2002-01-01\"))\n```\n:::\n\n\n:::\n\nHowever, for a smaller time frame of just 5 years after the re-unification, the\nbias could overturn the effect! Be careful when you choose a time period to\nmeasure cumulative effects as it will change the relative bias too.\n\n::: {.content-visible when-format=\"html\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngermany_synth$biasDraws(small_bias = 0.2, \n                        firstT = lubridate::as_date(\"1990-01-01\"), \n                        lastT = lubridate::as_date(\"1994-01-01\"))\n```\n:::\n\n\n:::\n\n::: {.callout-tip}\n## Learn more\n  - @abadie2021using Using Synthetic Controls: Feasibility, Data Requirements,\n    and Methodological Aspects.\n  - @abadie2022synthetic Synthetic Controls in Action.\n  - @martinez2023bayesian Bayesian and Frequentist Inference for Synthetic\n    Controls.\n:::\n",
    "supporting": [
      "bsynth_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}